{
  "hash": "db85a95f67712dee59605ad600a3f2bc",
  "result": {
    "markdown": "---\ntitle: \"Manipulating arrays with dynamic dimensions in R\"\ndescription: |\n  Challenges and solutions for creating functions to manipulate arrays in R when the number of dimensions is unknown. \nauthor:\n  - name: Emi Tanaka\n    url: https://emitanaka.org\n    affiliation: Monash University\n    affiliation_url: https://numbat.space/\ndate: 2022-01-18\ncategories: [R, programming]\nformat:\n  html:\n    highlight: default\n    toc: true\n    toc_float: true\nimage: https://www.r-project.org/Rlogo.png\n---\n\n\n\n\n## Introduction to `array`s in R\n\nBelow I am creating an array of dimensions $3 \\times 2 \\times 4$ with each entry containing a unique value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:24, dim = c(3, 2, 4))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"array\"\n```\n:::\n:::\n\n\nYou can access the entry $(1, 1, 1)$, i.e. the cell value in first entries of each dimension, in R by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1, 1, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nIf you want the entries $(i, 1, 1)$ where $i = 1, 2, 3$ then you can leave the first element blank in R like below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 1, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nIn the above code, the result is a vector but if you wanted to keep the array structure as is then you could add `drop = FALSE` like below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 1, 1, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n```\n:::\n:::\n\n\nIf you want the entries $(1, j, k)$ where $j = 1, 2$ and $k = 1, 2, 3, 4$, then you can leave the first two entries in the square bracket like below: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    4   10   16   22\n```\n:::\n:::\n\n\nThe above result isn't actually a vector but a two dimensional array, or more specifically it has the classes `matrix` and `array`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x[1, , ])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\n\nI can modify elements in an array by using the assignment operator (`<-` or `=`) like below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx3 <- x2 <- x\nx2[1, , ] <- NA\nx2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nx3[1, , ] <- array(1:8, dim = c(2, 4))\nx3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    3    4\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]    5    6\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]    7    8\n[2,]   20   23\n[3,]   21   24\n```\n:::\n:::\n\n\n\n## The challenge\n\n### Challenge 1: indexing\n\nUp to this point, it's pretty straight forward. But let's say now we create a function that returns the first element of the first dimension. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nindex_first <- function(x) {\n  x[1, , ]\n}\n\nindex_first(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    4   10   16   22\n```\n:::\n\n```{.r .cell-code}\ny <- array(1, dim = c(2, 4, 2))\nindex_first(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    1\n[3,]    1    1\n[4,]    1    1\n```\n:::\n:::\n\n\nThe above function works fine for the arrays `x` and `y`. But what if the number of dimension is different?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- array(dim = c(2, 2, 2, 2))\nindex_first(z)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x[1, , ]: incorrect number of dimensions\n```\n:::\n:::\n\n\nSo how do we change our function so it works for an array of any number of dimensions? This is where it gets quite challenging. And while I'm at it, let me throw another challenge. \n\n### Challenge 2: assignment\n\nSuppose now I want a function that modifies the entries in the first element of the first dimension by a user supplied value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_first <- function(x, value) {\n  x[1, ,] <- value\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_first(x, NA)\nmodify_first(x, array(1:8, dim = c(2, 4)))\n```\n:::\n\n\nAgain this works fine until we have an array with different number of dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_first(z, 1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x[1, , ] <- value: incorrect number of subscripts\n```\n:::\n:::\n\n\nSo how would you modify the function so this can be generalised for arrays with a different number of dimensions?\n\n## Solutions\n\nIn the first instance, it's useful to know that the square brackets are in fact functions so the codes below are equivalent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`[`(x, 1, , )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    4   10   16   22\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    4   10   16   22\n```\n:::\n:::\n\n\nThe assignment operator for arrays can be written like below where the last argument is the value to replace the indexed array.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`[<-`(x2, 1, , , 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]    0    0\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]    0    0\n[2,]   20   23\n[3,]   21   24\n```\n:::\n:::\n\n\nBelow is similar. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx2[1, , ] <- 0\n```\n:::\n\n\nI say similar because the above actually modifies `x2` but the call before that didn't. Below is the actual equivalent operation. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx2 <- `[<-`(x2, 1, , , 0)\n```\n:::\n\n\n<details>\n<summary>Solution for indexing</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindex_first <- function(x) {\n  d <- dim(x)\n  do.call(\"[\", c(list(x, 1), rep(list(bquote()), length(d) - 1)))\n}\n\nindex_first(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    4   10   16   22\n```\n:::\n\n```{.r .cell-code}\nindex_first(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]   NA   NA\n\n, , 2\n\n     [,1] [,2]\n[1,]   NA   NA\n[2,]   NA   NA\n```\n:::\n:::\n\n\n</details>\n\n<details>\n<summary>Solution for assignment</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_first <- function(x, value) {\n  d <- dim(x)\n  do.call(\"[<-\", c(list(x, 1), rep(list(bquote()), length(d) - 1), list(value)))\n}\n\nmodify_first(x, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    3    3\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    3    3\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nmodify_first(z, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1, 1\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   NA   NA\n\n, , 2, 1\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   NA   NA\n\n, , 1, 2\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   NA   NA\n\n, , 2, 2\n\n     [,1] [,2]\n[1,]    3    3\n[2,]   NA   NA\n```\n:::\n:::\n\n\n</details>\n\n## Practice \n\nSo you might wonder when you need such a result. I actually used this for the [`edibble`](https://github.com/emitanaka/edibble) R-package to create a kind of generalised version of Latin square design, i.e. an array that kind of stitches up multiple Latin squares.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nedibble::latin_array(dim = c(3, 3, 3), nt = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    3    2    1\n[3,]    2    1    3\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    2    1    3\n[2,]    1    3    2\n[3,]    3    2    1\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]    3    2    1\n[2,]    2    1    3\n[3,]    1    3    2\n```\n:::\n:::\n\n\nBeyond the above, I'm not sure who needs to manipulate arrays with dynamic dimensions. If you have a use case, I'd love to know.\n\n\n## Advanced R Programming unit\n\nThe above challenges are sort of challenges that I hope to include in the Advanced R Programming unit that's planned for Honours level in the Business Analytics major at Monash University. If you want to learn more about R as a programming lanuage (instead of a data analysis tool) then I'd recommend the [Advanced R book by Hadley Wickham](https://adv-r.hadley.nz/). \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://www.r-project.org/Rlogo.png)\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}